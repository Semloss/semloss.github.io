# boost库详解

## smart_ptr

### share_ptr类

#### 特殊成员

```c++
template<class T> class shared_ptr{
//class声明
private:
	//将自身的类型定义为this_type，但是是private成员
	//所以只有自身的成员函数和友元可以访问
	typedef shared_ptr<T> this_type;
	
	//模版友元类
	//所有的类型不为T的shared_ptr类都是类型为T的shard_ptr
	//的友元类（weak_ptr也是相同的道理）
	template<class Y> friend class shated_ptr;
	template<class Y> friend class weak_ptr;
	
	typedef typename boost::detail::sp_element< T >::type element_type;
	
	//指针类型的
	//element_type
	element_type * px;
	
	//智能指针的计数器
	//boost::detail::shared
	boost::detail::shared_count pn;
};
```

#### 下面进行部分代码的解释

#### boost::detail::sp_element

```c++
//实现代码如下
template< class T> struct sp_element
{
	typedef T type;
}
//其实就是模版类型参数的类型
//example:
//但是不知道为什么要这样实现
//难道是因为C++的三大特性之一： 封装？？？
	boost::detail::sp_element< int >::type 就是指的是int类型
```

#### boost::detail::shared_count

```c++
//file: boost/smart_ptr/detail/shared_count.hpp
class shared_count
{
	//其他实现
	...
	private:
	sp_counted_base * pi_;
	//其他实现
	...
}

//file: boost/smart_ptr/detail/sp_counted_base_std_atomic.hpp
//采用默认的GCC属性，可能某些相同名字的符号需要被隐藏，而这个需要被导出(default)
//define BOOST_SYMBOL_VISIBLE __attribute__((__visibility__("default")))
//__attribute__((__visibility__("hiden"))) 表示符号表需要被隐藏
class BOOST_SYMBOL_VISIBLE sp_counted_base
{
private:
	std::atomic_int_least32_t use_count_;
	std::atomic_int_least32_t weak_count_;
}

//typedef atomic<int_least32_t>  atomic_int_least32_t;
```

可以看出来**share_ptr**中的**boost::detail::shared_count pn**成员其实就是一个类似于**unsigned\***的东西。

## 继续分析smart_ptr成员函数 05-19 00:05

### 